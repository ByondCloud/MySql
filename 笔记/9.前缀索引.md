## 概念

如果说我们需要查询的某个列是很长很长的字符串，我们构建索引，这个索引的体积不就特别大，查询的时候也很影响IO性能，从而影响查询效率

例如邮箱，他们的后缀大部分都是@xxx.com，我们进行索引的时候大概率是用不上这一段的

解决方法是可以构建前缀索引，只将字符串的一部分前缀来构建索引，这样就可以减少索引的体积，从而提高索引效率



## 语法

```mysql
create index 索引名 on 表名 (列名(前缀长度))
```

索引的长度可以这么找，不重复的数量 / 总数

```mysql
select count(distinct email) / count(*) from tb_user; # 1
```

在索引长度最短，且最接近1的数最佳

```mysql
select count(distinct substring(email, 1, 5)) / count(*) from tb_user;
```

![image-20230418160221261](image/9.%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95/image-20230418160221261.png)
例如上面的例子，我们截取前10个是1，代表没有重复，我们索引的效率是最高的，只需要一次就可以精准命中
但是到了截取9个的时候，就下降到了0.9583，而截取5个也是0.9583，说明如果需要9和5做选择，你可以直接选择截取的长度为5
这个截取的长度需要根据自身来出发，看看这个场景适合什么业务，再做选择

通过email的前缀5位来建立索引

```mysql
create index index_email_5 on tb_user (email(5));
```

![image-20230418160826463](image/9.%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95/image-20230418160826463.png)

我们可以看到，使用了该索引



## 解释

![image-20230418163759409](image/9.%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95/image-20230418163759409.png)

首先会查询前缀索引，找到了会通过叶子节点的id进行回表查询，回表查询的时候会进行完整的匹配，如果不对，则会重新回到前缀索引中继续找下一个，重复以上的步骤，到找完所有的数据，拼装然后返回